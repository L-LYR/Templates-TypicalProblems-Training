# 图

## 图的概念即相关名词

这里不再详细介绍。

## 图的存储

- 邻接矩阵
  - `g[max_row][max_col]`，即二维数组。
  - `g[i][j] = 1`或者`g[i][j] = weight(i, j)`表示存在边`(i, j)`，`g[i][j] = 0`或者`g[i][j] = INF`表示不存在边`(i, j)`，根据题目需要选用。
- 邻接表
  - 常用方法：`vector<Edge> g[max_n]`，其中边结构题自定义，如`Edge{int from, to, dist, cost;}`。

- INF的取法：
  - 非负权可以用`-1`，需特判。
  - 含负权常用`0x3f3f3f3f`，满足`INF+INF=INF`。
  - 以上两种皆可用`memset`初始化。

## 相关问题及算法

### 拓扑排序

#### 问题描述

- 对DAG的顶点进行排序，结果要求：
  - 对于每个顶点仅出现一次
  - 对于顶点对(u, v)，若排序后u在v前，则不存在v到u的路径
- 一般是随着排序过程处理顶点信息，不需要显式结果

#### 算法流程

1. 建图时记录每一个点的入度
2. 建立队列，初始化将所有入度为0的点加入队列
    1. 依次从队列中取点，枚举以其为起点的边，进行信息更新（题目要求）
    2. 将被枚举的边的终点入度减1（取出的点已经进行了应该有的操作，相当与从图中删除）若此时出现入度为0的点则加入队列。
    3. 循环直至队列为空
3. 若图中点均被访问过，则说明可以排序;否则不可。
